---
title: unityShader入门精要
---

# 渲染基础介绍

## 基本渲染流水线

- 渲染流程分为 应用阶段，几何阶段，光栅化阶段



### 应用阶段

应用阶段由应用主导，通常在cpu上实现，主要任务是准备场景数据，进行粗剔除，设置渲染状态，输出渲染图元到几何阶段



### 几何阶段

这个阶段主要在GPU上实现，几何阶段需要处理每一个渲染图元，进行逐顶点，逐多边形操作，最后输出二维屏幕空间上的顶点坐标，顶点上包含了颜色，深度等信息，输出给下一个阶段使用




### 光栅化阶段

这个阶段负责用上一阶段的数据来生成屏幕上面的具体数据，光栅化决定了图元里面哪些像素该被绘制到屏幕上，以及通过逐顶点插值来决定像素的颜色



## CPU和GPU通信

- 渲染流水线的起点是CPU，CPU从硬盘将对应的网格纹理等数据读到内存中，然后再将这些数据存入显存中，然后设置渲染状态，再调用DrawCall来让GPU进行工作



### 设置渲染状态

- 渲染状态就是设置决定场景的中的网格究竟会被以什么方式渲染，这个时候可以设置着色器，纹理，Uniform等
- 渲染状态的频繁切换会导致比较高昂的cpu消耗



### draw call

draw call就是一个命令，cpu给定一个draw call，指挥gpu按设置好的渲染状态来进行渲染，最终输出成屏幕像素，cpu和gpu之间通信是通过一个命令缓冲区来进行的，命令缓冲区有很多种命令，draw call是其中一种，draw call会带来渲染状态切换，这个过程cpu非常耗时
- draw call的cpu消耗比较高，每次需要进行渲染的状态切换，准备数据，资源绑定（设置顶点缓冲，材质参数等等）因此降低每帧渲染的draw call是性能优化的方向之一




### 合批

 合批就是降低draw call的有效手段之一，按照合批的分类可以分为静态合批，动态合批，GPUInstancing
- 静态合批指把场景中不动的物体（建筑，树木，地面）合并成一个大的Mesh
- 动态合批指运行中把很多小物体临时合并
- GPU Instancing指用同一套数据传不同参数来绘制大量相同或稍有不同的物体，这个优化在GPU端进行



## GPU流水线

流水线	| 说明
---------|---------
几何阶段：
顶点着色器 | 完全可编程，实现顶点空间变换，顶点着色等
曲面细分着色器 | 可选着色器，用于细分图元
几何着色器 | 可选着色器，被用于逐图元着色或产生更多图元
裁剪 | 把不在视野内的图元裁剪掉，并剔除某些图元面片，是可配置的
屏幕映射 |不可配置不可编程，负责把图元坐标转换到屏幕坐标中
光栅化阶段：
三角形设置 | 固定函数
三角形遍历 | 固定函数
片元着色器 | 完全可编程，逐片元着色
逐片元操作 | 不可编程但可配置，，负责最后的颜色修改，深度缓冲，混合等

### 顶点着色器

顶点着色器可以创建和销毁任意顶点，着色器本身并不知道顶点之间的关系，是否属于同一个模型，顶点着色器主要的功能就是顶点坐标变换和逐顶点光照，这个着色器最后的数据经过光栅化后会丢给片元着色器去处理
- 顶点坐标变换指把顶点坐标从模型空间转换到齐次剪裁空间（o.pos = mul(UNITY_MVP, v.position)），再接着做透视除法以后得到归一化坐标（NDC）（把透视盒压缩为标准单位长度的方盒）



### 裁剪

不在齐次剪裁空间内的顶点需要进行剔除，一部分在内部的进行剪裁并生成新的顶点，这一部分不可编程，但是可以配置



### 屏幕映射

负责把图元坐标映射到屏幕上，转换为屏幕坐标系，屏幕坐标系是二维的，在openGL和directX中，屏幕坐标的原点并不一样，前一个是左下角，后一个是右上角



### 三角形设置（扫描变换）

准备三角形的边函数，重心坐标的插值系数，透视矫正插值等，并提供给下一个阶段



### 三角形遍历

三角形遍历阶段会查找每个像素是否被三角网格覆盖（判断像素是否在三角形内），如果被覆盖，就生成一个片元，同时根据三个顶点的数据来插值算出每个像素的信息
MSAA抗锯齿在这里解决锯齿走样，通过对一个像素进行多个点的采样进行图像模糊，除此外还要FXAA(后期图像处理)和TAA



### 片元着色器

通过上一阶段拿到的插值数据，最终通过各种计算得到最后单个像素的颜色，这一步可以完成各种自定义效果，但是这一步只能影响到单个片元，而不能将结果发散到周围片元上



### 逐片元操作

这一阶段主要对片元进行可见性测试和混合
- 关于测试，测试是可配置的，有很多类型
- 模板测试关乎于模板缓冲，进行模板测试时，会取出模板缓冲区的值和片元的模板值进行比较，比较函数可以由开发者决定，最后通过测试的进入下一个测试阶段或者进行混合，否则片元将会舍弃阴影渲染和轮廓渲染。
- 深度测试类似于模板测试，也有深度缓冲区，用来比较好确定片元的前后遮挡关系，所以透明效果和深度测试的关系十分密切，深度测试的比较函数也可以由开发者制定，与模板测试不同的是如果片元没有通过深度测试，那就无权更改深度缓冲区的值，有时候深度测试会在片元着色器之前，以此来避免最后被舍弃的片元还要进行一次片元着色的性能消耗（Earlt-Z）
- 关于混合，混合的时候如果并没有开启混合，新的片元的颜色会直接取代颜色缓冲区的值，如果开启混合的话，GPU就会拿当前片元的颜色和颜色缓冲区的颜色进行混合，混合的函数一般和透明通道息息相关



# Unity Shader

Shader就是GPU流水线上高度可编程的阶段，着色器编译出来的代码会在GPU上运行，即也是特定类型的着色器，例如顶点着色器，片元着色器



## 概述

unity的shader开发使用流程是：创建一个材质，创建对应的Shader并将其赋给材质，在材质上调整shader里面的属性并把材质赋给具体的游戏对象，unity可以直接在project面板右键创建shader模板，其中standard surface创建包含标准光照的着色器，Unlit创建一个不包含光照的基本顶点片元着色器，Image Effect创建一个屏幕后处理shader，Compute创建专门用来进行GPU并行计算的shader



## ShaderLab

在写一个标准着色器的时候，开发者需要根据不同平台选择不同的接口，要考虑各种文件的加载和渲染状态的设置，由此Unity提供了一个更为上层的说明性语言ShaderLab，以方便开发者更轻松的控制渲染，ShaderLab通过使用嵌套在花括号内的语义来描述自己的文件结构，例如在Properties语句块中定义了着色器的各种属性，这些属性都会在材质面板中显示，Unity在背后会根据使用的平台把ShaderLab编译成真正的代码和Shader文件

``` shaderlab
Shader "ShaderName"
{
	Properties //属性
	{

	}
	SubShader //显卡1使用的子着色器
	{

	}
	SunShader //显卡2使用的子着色器
	{

	}
	Fallback "VertexLit"

}

```

### Properties块

``` shaderlab
    Properties
    {
		//这里声明以后，就可以在外面的材质面板进行控制
		//Properties块里面的属性主要是为了将控制暴露在外，在具体的着色器代码块中还需要再声明一次才能和这里的属性建立连接
		//前面的_XXX是让代码使用的，后面的""里面的内容是外面材质面板显示的名字，逗号后面的参数是属性类型，等号右边是默认值
		_MainTex ("Texture", 2D) = "white" {}
		_Int("intTest", Int) = 3
		_Float("floatTest", Float) = 1.1
		_Color("colorTest", Color) = (1,1,1,1)
		_Float4("float4Test", Vector) = (1,1,1,1)
		_Range("rangeTest", Range(5, 0)) = 1
		_TestTex("TextureTest", 2D) = "white"{} //前面的""中放的是unity的默认纹理，后面的{}通常留空即可
		_TestTex("TextureTest", 2D) = "black"{} //
		_TestTex("TextureTest", 2D) = "gray"{} //
		_TestTex("TextureTest", 2D) = "bump"{} //bump指的是法线贴图
    }

```

### SubShader 块 



### FallBack块

当所有的SubShader都必能在当前的平台上运行，就会选择FallBack块指定的Shader来渲染